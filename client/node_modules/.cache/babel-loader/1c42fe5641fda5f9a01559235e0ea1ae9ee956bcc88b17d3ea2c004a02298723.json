{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CursorTimeoutContext = exports.AbstractCursor = exports.CursorTimeoutMode = exports.CURSOR_FLAGS = void 0;\nconst stream_1 = require(\"stream\");\nconst bson_1 = require(\"../bson\");\nconst error_1 = require(\"../error\");\nconst mongo_types_1 = require(\"../mongo_types\");\nconst execute_operation_1 = require(\"../operations/execute_operation\");\nconst get_more_1 = require(\"../operations/get_more\");\nconst kill_cursors_1 = require(\"../operations/kill_cursors\");\nconst read_concern_1 = require(\"../read_concern\");\nconst read_preference_1 = require(\"../read_preference\");\nconst resource_management_1 = require(\"../resource_management\");\nconst sessions_1 = require(\"../sessions\");\nconst timeout_1 = require(\"../timeout\");\nconst utils_1 = require(\"../utils\");\n/** @public */\nexports.CURSOR_FLAGS = ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'exhaust', 'partial'];\n/**\n * @public\n * @experimental\n * Specifies how `timeoutMS` is applied to the cursor. Can be either `'cursorLifeTime'` or `'iteration'`\n * When set to `'iteration'`, the deadline specified by `timeoutMS` applies to each call of\n * `cursor.next()`.\n * When set to `'cursorLifetime'`, the deadline applies to the life of the entire cursor.\n *\n * Depending on the type of cursor being used, this option has different default values.\n * For non-tailable cursors, this value defaults to `'cursorLifetime'`\n * For tailable cursors, this value defaults to `'iteration'` since tailable cursors, by\n * definition can have an arbitrarily long lifetime.\n *\n * @example\n * ```ts\n * const cursor = collection.find({}, {timeoutMS: 100, timeoutMode: 'iteration'});\n * for await (const doc of cursor) {\n *  // process doc\n *  // This will throw a timeout error if any of the iterator's `next()` calls takes more than 100ms, but\n *  // will continue to iterate successfully otherwise, regardless of the number of batches.\n * }\n * ```\n *\n * @example\n * ```ts\n * const cursor = collection.find({}, { timeoutMS: 1000, timeoutMode: 'cursorLifetime' });\n * const docs = await cursor.toArray(); // This entire line will throw a timeout error if all batches are not fetched and returned within 1000ms.\n * ```\n */\nexports.CursorTimeoutMode = Object.freeze({\n  ITERATION: 'iteration',\n  LIFETIME: 'cursorLifetime'\n});\n/** @public */\nclass AbstractCursor extends mongo_types_1.TypedEventEmitter {\n  /** @internal */\n  constructor(client, namespace, options = {}) {\n    super();\n    /** @internal */\n    this.documents = null;\n    /** @internal */\n    this.hasEmittedClose = false;\n    if (!client.s.isMongoClient) {\n      throw new error_1.MongoRuntimeError('Cursor must be constructed with MongoClient');\n    }\n    this.cursorClient = client;\n    this.cursorNamespace = namespace;\n    this.cursorId = null;\n    this.initialized = false;\n    this.isClosed = false;\n    this.isKilled = false;\n    this.cursorOptions = {\n      readPreference: options.readPreference && options.readPreference instanceof read_preference_1.ReadPreference ? options.readPreference : read_preference_1.ReadPreference.primary,\n      ...(0, bson_1.pluckBSONSerializeOptions)(options),\n      timeoutMS: options?.timeoutContext?.csotEnabled() ? options.timeoutContext.timeoutMS : options.timeoutMS,\n      tailable: options.tailable,\n      awaitData: options.awaitData\n    };\n    if (this.cursorOptions.timeoutMS != null) {\n      if (options.timeoutMode == null) {\n        if (options.tailable) {\n          if (options.awaitData) {\n            if (options.maxAwaitTimeMS != null && options.maxAwaitTimeMS >= this.cursorOptions.timeoutMS) throw new error_1.MongoInvalidArgumentError('Cannot specify maxAwaitTimeMS >= timeoutMS for a tailable awaitData cursor');\n          }\n          this.cursorOptions.timeoutMode = exports.CursorTimeoutMode.ITERATION;\n        } else {\n          this.cursorOptions.timeoutMode = exports.CursorTimeoutMode.LIFETIME;\n        }\n      } else {\n        if (options.tailable && options.timeoutMode === exports.CursorTimeoutMode.LIFETIME) {\n          throw new error_1.MongoInvalidArgumentError(\"Cannot set tailable cursor's timeoutMode to LIFETIME\");\n        }\n        this.cursorOptions.timeoutMode = options.timeoutMode;\n      }\n    } else {\n      if (options.timeoutMode != null) throw new error_1.MongoInvalidArgumentError('Cannot set timeoutMode without setting timeoutMS');\n    }\n    // Set for initial command\n    this.cursorOptions.omitMaxTimeMS = this.cursorOptions.timeoutMS != null && (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION && !this.cursorOptions.tailable || this.cursorOptions.tailable && !this.cursorOptions.awaitData);\n    const readConcern = read_concern_1.ReadConcern.fromOptions(options);\n    if (readConcern) {\n      this.cursorOptions.readConcern = readConcern;\n    }\n    if (typeof options.batchSize === 'number') {\n      this.cursorOptions.batchSize = options.batchSize;\n    }\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (options.comment !== undefined) {\n      this.cursorOptions.comment = options.comment;\n    }\n    if (typeof options.maxTimeMS === 'number') {\n      this.cursorOptions.maxTimeMS = options.maxTimeMS;\n    }\n    if (typeof options.maxAwaitTimeMS === 'number') {\n      this.cursorOptions.maxAwaitTimeMS = options.maxAwaitTimeMS;\n    }\n    if (options.session instanceof sessions_1.ClientSession) {\n      this.cursorSession = options.session;\n    } else {\n      this.cursorSession = this.cursorClient.startSession({\n        owner: this,\n        explicit: false\n      });\n    }\n    this.deserializationOptions = {\n      ...this.cursorOptions,\n      validation: {\n        utf8: options?.enableUtf8Validation === false ? false : true\n      }\n    };\n    this.timeoutContext = options.timeoutContext;\n  }\n  /**\n   * The cursor has no id until it receives a response from the initial cursor creating command.\n   *\n   * It is non-zero for as long as the database has an open cursor.\n   *\n   * The initiating command may receive a zero id if the entire result is in the `firstBatch`.\n   */\n  get id() {\n    return this.cursorId ?? undefined;\n  }\n  /** @internal */\n  get isDead() {\n    return (this.cursorId?.isZero() ?? false) || this.isClosed || this.isKilled;\n  }\n  /** @internal */\n  get client() {\n    return this.cursorClient;\n  }\n  /** @internal */\n  get server() {\n    return this.selectedServer;\n  }\n  get namespace() {\n    return this.cursorNamespace;\n  }\n  get readPreference() {\n    return this.cursorOptions.readPreference;\n  }\n  get readConcern() {\n    return this.cursorOptions.readConcern;\n  }\n  /** @internal */\n  get session() {\n    return this.cursorSession;\n  }\n  set session(clientSession) {\n    this.cursorSession = clientSession;\n  }\n  /**\n   * The cursor is closed and all remaining locally buffered documents have been iterated.\n   */\n  get closed() {\n    return this.isClosed && (this.documents?.length ?? 0) === 0;\n  }\n  /**\n   * A `killCursors` command was attempted on this cursor.\n   * This is performed if the cursor id is non zero.\n   */\n  get killed() {\n    return this.isKilled;\n  }\n  get loadBalanced() {\n    return !!this.cursorClient.topology?.loadBalanced;\n  }\n  /** @internal */\n  async asyncDispose() {\n    await this.close();\n  }\n  /** Returns current buffered documents length */\n  bufferedCount() {\n    return this.documents?.length ?? 0;\n  }\n  /** Returns current buffered documents */\n  readBufferedDocuments(number) {\n    const bufferedDocs = [];\n    const documentsToRead = Math.min(number ?? this.documents?.length ?? 0, this.documents?.length ?? 0);\n    for (let count = 0; count < documentsToRead; count++) {\n      const document = this.documents?.shift(this.deserializationOptions);\n      if (document != null) {\n        bufferedDocs.push(document);\n      }\n    }\n    return bufferedDocs;\n  }\n  async *[Symbol.asyncIterator]() {\n    if (this.closed) {\n      return;\n    }\n    try {\n      while (true) {\n        if (this.isKilled) {\n          return;\n        }\n        if (this.closed) {\n          return;\n        }\n        if (this.cursorId != null && this.isDead && (this.documents?.length ?? 0) === 0) {\n          return;\n        }\n        const document = await this.next();\n        // eslint-disable-next-line no-restricted-syntax\n        if (document === null) {\n          return;\n        }\n        yield document;\n      }\n    } finally {\n      // Only close the cursor if it has not already been closed. This finally clause handles\n      // the case when a user would break out of a for await of loop early.\n      if (!this.isClosed) {\n        try {\n          await this.close();\n        } catch (error) {\n          (0, utils_1.squashError)(error);\n        }\n      }\n    }\n  }\n  stream(options) {\n    if (options?.transform) {\n      const transform = options.transform;\n      const readable = new ReadableCursorStream(this);\n      const transformedStream = readable.pipe(new stream_1.Transform({\n        objectMode: true,\n        highWaterMark: 1,\n        transform(chunk, _, callback) {\n          try {\n            const transformed = transform(chunk);\n            callback(undefined, transformed);\n          } catch (err) {\n            callback(err);\n          }\n        }\n      }));\n      // Bubble errors to transformed stream, because otherwise no way\n      // to handle this error.\n      readable.on('error', err => transformedStream.emit('error', err));\n      return transformedStream;\n    }\n    return new ReadableCursorStream(this);\n  }\n  async hasNext() {\n    if (this.cursorId === bson_1.Long.ZERO) {\n      return false;\n    }\n    if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION && this.cursorId != null) {\n      this.timeoutContext?.refresh();\n    }\n    try {\n      do {\n        if ((this.documents?.length ?? 0) !== 0) {\n          return true;\n        }\n        await this.fetchBatch();\n      } while (!this.isDead || (this.documents?.length ?? 0) !== 0);\n    } finally {\n      if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION) {\n        this.timeoutContext?.clear();\n      }\n    }\n    return false;\n  }\n  /** Get the next available document from the cursor, returns null if no more documents are available. */\n  async next() {\n    if (this.cursorId === bson_1.Long.ZERO) {\n      throw new error_1.MongoCursorExhaustedError();\n    }\n    if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION && this.cursorId != null) {\n      this.timeoutContext?.refresh();\n    }\n    try {\n      do {\n        const doc = this.documents?.shift(this.deserializationOptions);\n        if (doc != null) {\n          if (this.transform != null) return await this.transformDocument(doc);\n          return doc;\n        }\n        await this.fetchBatch();\n      } while (!this.isDead || (this.documents?.length ?? 0) !== 0);\n    } finally {\n      if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION) {\n        this.timeoutContext?.clear();\n      }\n    }\n    return null;\n  }\n  /**\n   * Try to get the next available document from the cursor or `null` if an empty batch is returned\n   */\n  async tryNext() {\n    if (this.cursorId === bson_1.Long.ZERO) {\n      throw new error_1.MongoCursorExhaustedError();\n    }\n    if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION && this.cursorId != null) {\n      this.timeoutContext?.refresh();\n    }\n    try {\n      let doc = this.documents?.shift(this.deserializationOptions);\n      if (doc != null) {\n        if (this.transform != null) return await this.transformDocument(doc);\n        return doc;\n      }\n      await this.fetchBatch();\n      doc = this.documents?.shift(this.deserializationOptions);\n      if (doc != null) {\n        if (this.transform != null) return await this.transformDocument(doc);\n        return doc;\n      }\n    } finally {\n      if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION) {\n        this.timeoutContext?.clear();\n      }\n    }\n    return null;\n  }\n  /**\n   * Iterates over all the documents for this cursor using the iterator, callback pattern.\n   *\n   * If the iterator returns `false`, iteration will stop.\n   *\n   * @param iterator - The iteration callback.\n   * @deprecated - Will be removed in a future release. Use for await...of instead.\n   */\n  async forEach(iterator) {\n    if (typeof iterator !== 'function') {\n      throw new error_1.MongoInvalidArgumentError('Argument \"iterator\" must be a function');\n    }\n    for await (const document of this) {\n      const result = iterator(document);\n      if (result === false) {\n        break;\n      }\n    }\n  }\n  /**\n   * Frees any client-side resources used by the cursor.\n   */\n  async close(options) {\n    await this.cleanup(options?.timeoutMS);\n  }\n  /**\n   * Returns an array of documents. The caller is responsible for making sure that there\n   * is enough memory to store the results. Note that the array only contains partial\n   * results when this cursor had been previously accessed. In that case,\n   * cursor.rewind() can be used to reset the cursor.\n   */\n  async toArray() {\n    const array = [];\n    // at the end of the loop (since readBufferedDocuments is called) the buffer will be empty\n    // then, the 'await of' syntax will run a getMore call\n    for await (const document of this) {\n      array.push(document);\n      const docs = this.readBufferedDocuments();\n      if (this.transform != null) {\n        for (const doc of docs) {\n          array.push(await this.transformDocument(doc));\n        }\n      } else {\n        array.push(...docs);\n      }\n    }\n    return array;\n  }\n  /**\n   * Add a cursor flag to the cursor\n   *\n   * @param flag - The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial' -.\n   * @param value - The flag boolean value.\n   */\n  addCursorFlag(flag, value) {\n    this.throwIfInitialized();\n    if (!exports.CURSOR_FLAGS.includes(flag)) {\n      throw new error_1.MongoInvalidArgumentError(`Flag ${flag} is not one of ${exports.CURSOR_FLAGS}`);\n    }\n    if (typeof value !== 'boolean') {\n      throw new error_1.MongoInvalidArgumentError(`Flag ${flag} must be a boolean value`);\n    }\n    this.cursorOptions[flag] = value;\n    return this;\n  }\n  /**\n   * Map all documents using the provided function\n   * If there is a transform set on the cursor, that will be called first and the result passed to\n   * this function's transform.\n   *\n   * @remarks\n   *\n   * **Note** Cursors use `null` internally to indicate that there are no more documents in the cursor. Providing a mapping\n   * function that maps values to `null` will result in the cursor closing itself before it has finished iterating\n   * all documents.  This will **not** result in a memory leak, just surprising behavior.  For example:\n   *\n   * ```typescript\n   * const cursor = collection.find({});\n   * cursor.map(() => null);\n   *\n   * const documents = await cursor.toArray();\n   * // documents is always [], regardless of how many documents are in the collection.\n   * ```\n   *\n   * Other falsey values are allowed:\n   *\n   * ```typescript\n   * const cursor = collection.find({});\n   * cursor.map(() => '');\n   *\n   * const documents = await cursor.toArray();\n   * // documents is now an array of empty strings\n   * ```\n   *\n   * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\n   * it **does not** return a new instance of a cursor. This means when calling map,\n   * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\n   * Take note of the following example:\n   *\n   * @example\n   * ```typescript\n   * const cursor: FindCursor<Document> = coll.find();\n   * const mappedCursor: FindCursor<number> = cursor.map(doc => Object.keys(doc).length);\n   * const keyCounts: number[] = await mappedCursor.toArray(); // cursor.toArray() still returns Document[]\n   * ```\n   * @param transform - The mapping transformation method.\n   */\n  map(transform) {\n    this.throwIfInitialized();\n    const oldTransform = this.transform;\n    if (oldTransform) {\n      this.transform = doc => {\n        return transform(oldTransform(doc));\n      };\n    } else {\n      this.transform = transform;\n    }\n    return this;\n  }\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n  withReadPreference(readPreference) {\n    this.throwIfInitialized();\n    if (readPreference instanceof read_preference_1.ReadPreference) {\n      this.cursorOptions.readPreference = readPreference;\n    } else if (typeof readPreference === 'string') {\n      this.cursorOptions.readPreference = read_preference_1.ReadPreference.fromString(readPreference);\n    } else {\n      throw new error_1.MongoInvalidArgumentError(`Invalid read preference: ${readPreference}`);\n    }\n    return this;\n  }\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n  withReadConcern(readConcern) {\n    this.throwIfInitialized();\n    const resolvedReadConcern = read_concern_1.ReadConcern.fromOptions({\n      readConcern\n    });\n    if (resolvedReadConcern) {\n      this.cursorOptions.readConcern = resolvedReadConcern;\n    }\n    return this;\n  }\n  /**\n   * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)\n   *\n   * @param value - Number of milliseconds to wait before aborting the query.\n   */\n  maxTimeMS(value) {\n    this.throwIfInitialized();\n    if (typeof value !== 'number') {\n      throw new error_1.MongoInvalidArgumentError('Argument for maxTimeMS must be a number');\n    }\n    this.cursorOptions.maxTimeMS = value;\n    return this;\n  }\n  /**\n   * Set the batch size for the cursor.\n   *\n   * @param value - The number of documents to return per batch. See {@link https://www.mongodb.com/docs/manual/reference/command/find/|find command documentation}.\n   */\n  batchSize(value) {\n    this.throwIfInitialized();\n    if (this.cursorOptions.tailable) {\n      throw new error_1.MongoTailableCursorError('Tailable cursor does not support batchSize');\n    }\n    if (typeof value !== 'number') {\n      throw new error_1.MongoInvalidArgumentError('Operation \"batchSize\" requires an integer');\n    }\n    this.cursorOptions.batchSize = value;\n    return this;\n  }\n  /**\n   * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will\n   * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even\n   * if the resultant data has already been retrieved by this cursor.\n   */\n  rewind() {\n    if (this.timeoutContext && this.timeoutContext.owner !== this) {\n      throw new error_1.MongoAPIError(`Cannot rewind cursor that does not own its timeout context.`);\n    }\n    if (!this.initialized) {\n      return;\n    }\n    this.cursorId = null;\n    this.documents?.clear();\n    this.timeoutContext?.clear();\n    this.timeoutContext = undefined;\n    this.isClosed = false;\n    this.isKilled = false;\n    this.initialized = false;\n    const session = this.cursorSession;\n    if (session) {\n      // We only want to end this session if we created it, and it hasn't ended yet\n      if (session.explicit === false) {\n        if (!session.hasEnded) {\n          session.endSession().then(undefined, utils_1.squashError);\n        }\n        this.cursorSession = this.cursorClient.startSession({\n          owner: this,\n          explicit: false\n        });\n      }\n    }\n  }\n  /** @internal */\n  async getMore(batchSize) {\n    if (this.cursorId == null) {\n      throw new error_1.MongoRuntimeError('Unexpected null cursor id. A cursor creating command should have set this');\n    }\n    if (this.selectedServer == null) {\n      throw new error_1.MongoRuntimeError('Unexpected null selectedServer. A cursor creating command should have set this');\n    }\n    const getMoreOptions = {\n      ...this.cursorOptions,\n      session: this.cursorSession,\n      batchSize\n    };\n    const getMoreOperation = new get_more_1.GetMoreOperation(this.cursorNamespace, this.cursorId, this.selectedServer, getMoreOptions);\n    return await (0, execute_operation_1.executeOperation)(this.cursorClient, getMoreOperation, this.timeoutContext);\n  }\n  /**\n   * @internal\n   *\n   * This function is exposed for the unified test runner's createChangeStream\n   * operation.  We cannot refactor to use the abstract _initialize method without\n   * a significant refactor.\n   */\n  async cursorInit() {\n    if (this.cursorOptions.timeoutMS != null) {\n      this.timeoutContext ??= new CursorTimeoutContext(timeout_1.TimeoutContext.create({\n        serverSelectionTimeoutMS: this.client.s.options.serverSelectionTimeoutMS,\n        timeoutMS: this.cursorOptions.timeoutMS\n      }), this);\n    }\n    try {\n      const state = await this._initialize(this.cursorSession);\n      // Set omitMaxTimeMS to the value needed for subsequent getMore calls\n      this.cursorOptions.omitMaxTimeMS = this.cursorOptions.timeoutMS != null;\n      const response = state.response;\n      this.selectedServer = state.server;\n      this.cursorId = response.id;\n      this.cursorNamespace = response.ns ?? this.namespace;\n      this.documents = response;\n      this.initialized = true; // the cursor is now initialized, even if it is dead\n    } catch (error) {\n      // the cursor is now initialized, even if an error occurred\n      this.initialized = true;\n      await this.cleanup(undefined, error);\n      throw error;\n    }\n    if (this.isDead) {\n      await this.cleanup();\n    }\n    return;\n  }\n  /** @internal Attempt to obtain more documents */\n  async fetchBatch() {\n    if (this.isClosed) {\n      return;\n    }\n    if (this.isDead) {\n      // if the cursor is dead, we clean it up\n      // cleanupCursor should never throw, but if it does it indicates a bug in the driver\n      // and we should surface the error\n      await this.cleanup();\n      return;\n    }\n    if (this.cursorId == null) {\n      await this.cursorInit();\n      // If the cursor died or returned documents, return\n      if ((this.documents?.length ?? 0) !== 0 || this.isDead) return;\n      // Otherwise, run a getMore\n    }\n    // otherwise need to call getMore\n    const batchSize = this.cursorOptions.batchSize || 1000;\n    try {\n      const response = await this.getMore(batchSize);\n      this.cursorId = response.id;\n      this.documents = response;\n    } catch (error) {\n      try {\n        await this.cleanup(undefined, error);\n      } catch (cleanupError) {\n        // `cleanupCursor` should never throw, squash and throw the original error\n        (0, utils_1.squashError)(cleanupError);\n      }\n      throw error;\n    }\n    if (this.isDead) {\n      // If we successfully received a response from a cursor BUT the cursor indicates that it is exhausted,\n      // we intentionally clean up the cursor to release its session back into the pool before the cursor\n      // is iterated.  This prevents a cursor that is exhausted on the server from holding\n      // onto a session indefinitely until the AbstractCursor is iterated.\n      //\n      // cleanupCursorAsync should never throw, but if it does it indicates a bug in the driver\n      // and we should surface the error\n      await this.cleanup();\n    }\n  }\n  /** @internal */\n  async cleanup(timeoutMS, error) {\n    this.isClosed = true;\n    const session = this.cursorSession;\n    const timeoutContextForKillCursors = () => {\n      if (timeoutMS != null) {\n        this.timeoutContext?.clear();\n        return new CursorTimeoutContext(timeout_1.TimeoutContext.create({\n          serverSelectionTimeoutMS: this.client.s.options.serverSelectionTimeoutMS,\n          timeoutMS\n        }), this);\n      } else {\n        return this.timeoutContext?.refreshed();\n      }\n    };\n    try {\n      if (!this.isKilled && this.cursorId && !this.cursorId.isZero() && this.cursorNamespace && this.selectedServer && !session.hasEnded) {\n        this.isKilled = true;\n        const cursorId = this.cursorId;\n        this.cursorId = bson_1.Long.ZERO;\n        await (0, execute_operation_1.executeOperation)(this.cursorClient, new kill_cursors_1.KillCursorsOperation(cursorId, this.cursorNamespace, this.selectedServer, {\n          session\n        }), timeoutContextForKillCursors());\n      }\n    } catch (error) {\n      (0, utils_1.squashError)(error);\n    } finally {\n      if (session?.owner === this) {\n        await session.endSession({\n          error\n        });\n      }\n      if (!session?.inTransaction()) {\n        (0, sessions_1.maybeClearPinnedConnection)(session, {\n          error\n        });\n      }\n      this.emitClose();\n    }\n  }\n  /** @internal */\n  emitClose() {\n    try {\n      if (!this.hasEmittedClose && ((this.documents?.length ?? 0) === 0 || this.isClosed)) {\n        // @ts-expect-error: CursorEvents is generic so Parameters<CursorEvents[\"close\"]> may not be assignable to `[]`. Not sure how to require extenders do not add parameters.\n        this.emit('close');\n      }\n    } finally {\n      this.hasEmittedClose = true;\n    }\n  }\n  /** @internal */\n  async transformDocument(document) {\n    if (this.transform == null) return document;\n    try {\n      const transformedDocument = this.transform(document);\n      // eslint-disable-next-line no-restricted-syntax\n      if (transformedDocument === null) {\n        const TRANSFORM_TO_NULL_ERROR = 'Cursor returned a `null` document, but the cursor is not exhausted.  Mapping documents to `null` is not supported in the cursor transform.';\n        throw new error_1.MongoAPIError(TRANSFORM_TO_NULL_ERROR);\n      }\n      return transformedDocument;\n    } catch (transformError) {\n      try {\n        await this.close();\n      } catch (closeError) {\n        (0, utils_1.squashError)(closeError);\n      }\n      throw transformError;\n    }\n  }\n  /** @internal */\n  throwIfInitialized() {\n    if (this.initialized) throw new error_1.MongoCursorInUseError();\n  }\n}\nexports.AbstractCursor = AbstractCursor;\n/** @event */\nAbstractCursor.CLOSE = 'close';\nclass ReadableCursorStream extends stream_1.Readable {\n  constructor(cursor) {\n    super({\n      objectMode: true,\n      autoDestroy: false,\n      highWaterMark: 1\n    });\n    this._readInProgress = false;\n    this._cursor = cursor;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _read(size) {\n    if (!this._readInProgress) {\n      this._readInProgress = true;\n      this._readNext();\n    }\n  }\n  _destroy(error, callback) {\n    this._cursor.close().then(() => callback(error), closeError => callback(closeError));\n  }\n  _readNext() {\n    if (this._cursor.id === bson_1.Long.ZERO) {\n      this.push(null);\n      return;\n    }\n    this._cursor.next().then(result => {\n      if (result == null) {\n        this.push(null);\n      } else if (this.destroyed) {\n        this._cursor.close().then(undefined, utils_1.squashError);\n      } else {\n        if (this.push(result)) {\n          return this._readNext();\n        }\n        this._readInProgress = false;\n      }\n    }, err => {\n      // NOTE: This is questionable, but we have a test backing the behavior. It seems the\n      //       desired behavior is that a stream ends cleanly when a user explicitly closes\n      //       a client during iteration. Alternatively, we could do the \"right\" thing and\n      //       propagate the error message by removing this special case.\n      if (err.message.match(/server is closed/)) {\n        this._cursor.close().then(undefined, utils_1.squashError);\n        return this.push(null);\n      }\n      // NOTE: This is also perhaps questionable. The rationale here is that these errors tend\n      //       to be \"operation was interrupted\", where a cursor has been closed but there is an\n      //       active getMore in-flight. This used to check if the cursor was killed but once\n      //       that changed to happen in cleanup legitimate errors would not destroy the\n      //       stream. There are change streams test specifically test these cases.\n      if (err.message.match(/operation was interrupted/)) {\n        return this.push(null);\n      }\n      // NOTE: The two above checks on the message of the error will cause a null to be pushed\n      //       to the stream, thus closing the stream before the destroy call happens. This means\n      //       that either of those error messages on a change stream will not get a proper\n      //       'error' event to be emitted (the error passed to destroy). Change stream resumability\n      //       relies on that error event to be emitted to create its new cursor and thus was not\n      //       working on 4.4 servers because the error emitted on failover was \"interrupted at\n      //       shutdown\" while on 5.0+ it is \"The server is in quiesce mode and will shut down\".\n      //       See NODE-4475.\n      return this.destroy(err);\n    });\n  }\n}\n(0, resource_management_1.configureResourceManagement)(AbstractCursor.prototype);\n/**\n * @internal\n * The cursor timeout context is a wrapper around a timeout context\n * that keeps track of the \"owner\" of the cursor.  For timeout contexts\n * instantiated inside a cursor, the owner will be the cursor.\n *\n * All timeout behavior is exactly the same as the wrapped timeout context's.\n */\nclass CursorTimeoutContext extends timeout_1.TimeoutContext {\n  constructor(timeoutContext, owner) {\n    super();\n    this.timeoutContext = timeoutContext;\n    this.owner = owner;\n  }\n  get serverSelectionTimeout() {\n    return this.timeoutContext.serverSelectionTimeout;\n  }\n  get connectionCheckoutTimeout() {\n    return this.timeoutContext.connectionCheckoutTimeout;\n  }\n  get clearServerSelectionTimeout() {\n    return this.timeoutContext.clearServerSelectionTimeout;\n  }\n  get timeoutForSocketWrite() {\n    return this.timeoutContext.timeoutForSocketWrite;\n  }\n  get timeoutForSocketRead() {\n    return this.timeoutContext.timeoutForSocketRead;\n  }\n  csotEnabled() {\n    return this.timeoutContext.csotEnabled();\n  }\n  refresh() {\n    if (typeof this.owner !== 'symbol') return this.timeoutContext.refresh();\n  }\n  clear() {\n    if (typeof this.owner !== 'symbol') return this.timeoutContext.clear();\n  }\n  get maxTimeMS() {\n    return this.timeoutContext.maxTimeMS;\n  }\n  get timeoutMS() {\n    return this.timeoutContext.csotEnabled() ? this.timeoutContext.timeoutMS : null;\n  }\n  refreshed() {\n    return new CursorTimeoutContext(this.timeoutContext.refreshed(), this.owner);\n  }\n  addMaxTimeMSToCommand(command, options) {\n    this.timeoutContext.addMaxTimeMSToCommand(command, options);\n  }\n  getSocketTimeoutMS() {\n    return this.timeoutContext.getSocketTimeoutMS();\n  }\n}\nexports.CursorTimeoutContext = CursorTimeoutContext;","map":{"version":3,"names":["stream_1","require","bson_1","error_1","mongo_types_1","execute_operation_1","get_more_1","kill_cursors_1","read_concern_1","read_preference_1","resource_management_1","sessions_1","timeout_1","utils_1","exports","CURSOR_FLAGS","CursorTimeoutMode","Object","freeze","ITERATION","LIFETIME","AbstractCursor","TypedEventEmitter","constructor","client","namespace","options","documents","hasEmittedClose","s","isMongoClient","MongoRuntimeError","cursorClient","cursorNamespace","cursorId","initialized","isClosed","isKilled","cursorOptions","readPreference","ReadPreference","primary","pluckBSONSerializeOptions","timeoutMS","timeoutContext","csotEnabled","tailable","awaitData","timeoutMode","maxAwaitTimeMS","MongoInvalidArgumentError","omitMaxTimeMS","readConcern","ReadConcern","fromOptions","batchSize","comment","undefined","maxTimeMS","session","ClientSession","cursorSession","startSession","owner","explicit","deserializationOptions","validation","utf8","enableUtf8Validation","id","isDead","isZero","server","selectedServer","clientSession","closed","length","killed","loadBalanced","topology","asyncDispose","close","bufferedCount","readBufferedDocuments","number","bufferedDocs","documentsToRead","Math","min","count","document","shift","push","Symbol","asyncIterator","next","error","squashError","stream","transform","readable","ReadableCursorStream","transformedStream","pipe","Transform","objectMode","highWaterMark","chunk","_","callback","transformed","err","on","emit","hasNext","Long","ZERO","refresh","fetchBatch","clear","MongoCursorExhaustedError","doc","transformDocument","tryNext","forEach","iterator","result","cleanup","toArray","array","docs","addCursorFlag","flag","value","throwIfInitialized","includes","map","oldTransform","withReadPreference","fromString","withReadConcern","resolvedReadConcern","MongoTailableCursorError","rewind","MongoAPIError","hasEnded","endSession","then","getMore","getMoreOptions","getMoreOperation","GetMoreOperation","executeOperation","cursorInit","CursorTimeoutContext","TimeoutContext","create","serverSelectionTimeoutMS","state","_initialize","response","ns","cleanupError","timeoutContextForKillCursors","refreshed","KillCursorsOperation","inTransaction","maybeClearPinnedConnection","emitClose","transformedDocument","TRANSFORM_TO_NULL_ERROR","transformError","closeError","MongoCursorInUseError","CLOSE","Readable","cursor","autoDestroy","_readInProgress","_cursor","_read","size","_readNext","_destroy","destroyed","message","match","destroy","configureResourceManagement","prototype","serverSelectionTimeout","connectionCheckoutTimeout","clearServerSelectionTimeout","timeoutForSocketWrite","timeoutForSocketRead","addMaxTimeMSToCommand","command","getSocketTimeoutMS"],"sources":["C:\\Users\\ASUS\\Downloads\\testing\\chandan-enterprises\\node_modules\\mongodb\\src\\cursor\\abstract_cursor.ts"],"sourcesContent":["import { Readable, Transform } from 'stream';\n\nimport { type BSONSerializeOptions, type Document, Long, pluckBSONSerializeOptions } from '../bson';\nimport { type OnDemandDocumentDeserializeOptions } from '../cmap/wire_protocol/on_demand/document';\nimport { type CursorResponse } from '../cmap/wire_protocol/responses';\nimport {\n  MongoAPIError,\n  MongoCursorExhaustedError,\n  MongoCursorInUseError,\n  MongoInvalidArgumentError,\n  MongoRuntimeError,\n  MongoTailableCursorError\n} from '../error';\nimport type { MongoClient } from '../mongo_client';\nimport { TypedEventEmitter } from '../mongo_types';\nimport { executeOperation } from '../operations/execute_operation';\nimport { GetMoreOperation } from '../operations/get_more';\nimport { KillCursorsOperation } from '../operations/kill_cursors';\nimport { ReadConcern, type ReadConcernLike } from '../read_concern';\nimport { ReadPreference, type ReadPreferenceLike } from '../read_preference';\nimport { type AsyncDisposable, configureResourceManagement } from '../resource_management';\nimport type { Server } from '../sdam/server';\nimport { ClientSession, maybeClearPinnedConnection } from '../sessions';\nimport { type CSOTTimeoutContext, type Timeout, TimeoutContext } from '../timeout';\nimport { type MongoDBNamespace, squashError } from '../utils';\n\n/**\n * @internal\n * TODO(NODE-2882): A cursor's getMore commands must be run on the same server it was started on\n * and the same session must be used for the lifetime of the cursor. This object serves to get the\n * server and session (along with the response) out of executeOperation back to the AbstractCursor.\n *\n * There may be a better design for communicating these values back to the cursor, currently an operation\n * MUST store the selected server on itself so it can be read after executeOperation has returned.\n */\nexport interface InitialCursorResponse {\n  /** The server selected for the operation */\n  server: Server;\n  /** The session used for this operation, may be implicitly created */\n  session?: ClientSession;\n  /** The raw server response for the operation */\n  response: CursorResponse;\n}\n\n/** @public */\nexport const CURSOR_FLAGS = [\n  'tailable',\n  'oplogReplay',\n  'noCursorTimeout',\n  'awaitData',\n  'exhaust',\n  'partial'\n] as const;\n\n/** @public */\nexport interface CursorStreamOptions {\n  /** A transformation method applied to each document emitted by the stream */\n  transform?(this: void, doc: Document): Document;\n}\n\n/** @public */\nexport type CursorFlag = (typeof CURSOR_FLAGS)[number];\n\n/**\n * @public\n * @experimental\n * Specifies how `timeoutMS` is applied to the cursor. Can be either `'cursorLifeTime'` or `'iteration'`\n * When set to `'iteration'`, the deadline specified by `timeoutMS` applies to each call of\n * `cursor.next()`.\n * When set to `'cursorLifetime'`, the deadline applies to the life of the entire cursor.\n *\n * Depending on the type of cursor being used, this option has different default values.\n * For non-tailable cursors, this value defaults to `'cursorLifetime'`\n * For tailable cursors, this value defaults to `'iteration'` since tailable cursors, by\n * definition can have an arbitrarily long lifetime.\n *\n * @example\n * ```ts\n * const cursor = collection.find({}, {timeoutMS: 100, timeoutMode: 'iteration'});\n * for await (const doc of cursor) {\n *  // process doc\n *  // This will throw a timeout error if any of the iterator's `next()` calls takes more than 100ms, but\n *  // will continue to iterate successfully otherwise, regardless of the number of batches.\n * }\n * ```\n *\n * @example\n * ```ts\n * const cursor = collection.find({}, { timeoutMS: 1000, timeoutMode: 'cursorLifetime' });\n * const docs = await cursor.toArray(); // This entire line will throw a timeout error if all batches are not fetched and returned within 1000ms.\n * ```\n */\nexport const CursorTimeoutMode = Object.freeze({\n  ITERATION: 'iteration',\n  LIFETIME: 'cursorLifetime'\n} as const);\n\n/**\n * @public\n * @experimental\n */\nexport type CursorTimeoutMode = (typeof CursorTimeoutMode)[keyof typeof CursorTimeoutMode];\n\n/** @public */\nexport interface AbstractCursorOptions extends BSONSerializeOptions {\n  session?: ClientSession;\n  readPreference?: ReadPreferenceLike;\n  readConcern?: ReadConcernLike;\n  /**\n   * Specifies the number of documents to return in each response from MongoDB\n   */\n  batchSize?: number;\n  /**\n   * When applicable `maxTimeMS` controls the amount of time the initial command\n   * that constructs a cursor should take. (ex. find, aggregate, listCollections)\n   */\n  maxTimeMS?: number;\n  /**\n   * When applicable `maxAwaitTimeMS` controls the amount of time subsequent getMores\n   * that a cursor uses to fetch more data should take. (ex. cursor.next())\n   */\n  maxAwaitTimeMS?: number;\n  /**\n   * Comment to apply to the operation.\n   *\n   * In server versions pre-4.4, 'comment' must be string.  A server\n   * error will be thrown if any other type is provided.\n   *\n   * In server versions 4.4 and above, 'comment' can be any valid BSON type.\n   */\n  comment?: unknown;\n  /**\n   * By default, MongoDB will automatically close a cursor when the\n   * client has exhausted all results in the cursor. However, for [capped collections](https://www.mongodb.com/docs/manual/core/capped-collections)\n   * you may use a Tailable Cursor that remains open after the client exhausts\n   * the results in the initial cursor.\n   */\n  tailable?: boolean;\n  /**\n   * If awaitData is set to true, when the cursor reaches the end of the capped collection,\n   * MongoDB blocks the query thread for a period of time waiting for new data to arrive.\n   * When new data is inserted into the capped collection, the blocked thread is signaled\n   * to wake up and return the next batch to the client.\n   */\n  awaitData?: boolean;\n  noCursorTimeout?: boolean;\n  /** Specifies the time an operation will run until it throws a timeout error. See {@link AbstractCursorOptions.timeoutMode} for more details on how this option applies to cursors. */\n  timeoutMS?: number;\n  /**\n   * @public\n   * @experimental\n   * Specifies how `timeoutMS` is applied to the cursor. Can be either `'cursorLifeTime'` or `'iteration'`\n   * When set to `'iteration'`, the deadline specified by `timeoutMS` applies to each call of\n   * `cursor.next()`.\n   * When set to `'cursorLifetime'`, the deadline applies to the life of the entire cursor.\n   *\n   * Depending on the type of cursor being used, this option has different default values.\n   * For non-tailable cursors, this value defaults to `'cursorLifetime'`\n   * For tailable cursors, this value defaults to `'iteration'` since tailable cursors, by\n   * definition can have an arbitrarily long lifetime.\n   *\n   * @example\n   * ```ts\n   * const cursor = collection.find({}, {timeoutMS: 100, timeoutMode: 'iteration'});\n   * for await (const doc of cursor) {\n   *  // process doc\n   *  // This will throw a timeout error if any of the iterator's `next()` calls takes more than 100ms, but\n   *  // will continue to iterate successfully otherwise, regardless of the number of batches.\n   * }\n   * ```\n   *\n   * @example\n   * ```ts\n   * const cursor = collection.find({}, { timeoutMS: 1000, timeoutMode: 'cursorLifetime' });\n   * const docs = await cursor.toArray(); // This entire line will throw a timeout error if all batches are not fetched and returned within 1000ms.\n   * ```\n   */\n  timeoutMode?: CursorTimeoutMode;\n\n  /**\n   * @internal\n   *\n   * A timeout context to govern the total time the cursor can live.  If provided, the cursor\n   * cannot be used in ITERATION mode.\n   */\n  timeoutContext?: CursorTimeoutContext;\n}\n\n/** @internal */\nexport type InternalAbstractCursorOptions = Omit<AbstractCursorOptions, 'readPreference'> & {\n  // resolved\n  readPreference: ReadPreference;\n  readConcern?: ReadConcern;\n\n  // cursor flags, some are deprecated\n  oplogReplay?: boolean;\n  exhaust?: boolean;\n  partial?: boolean;\n\n  omitMaxTimeMS?: boolean;\n};\n\n/** @public */\nexport type AbstractCursorEvents = {\n  [AbstractCursor.CLOSE](): void;\n};\n\n/** @public */\nexport abstract class AbstractCursor<\n    TSchema = any,\n    CursorEvents extends AbstractCursorEvents = AbstractCursorEvents\n  >\n  extends TypedEventEmitter<CursorEvents>\n  implements AsyncDisposable\n{\n  /** @internal */\n  private cursorId: Long | null;\n  /** @internal */\n  private cursorSession: ClientSession;\n  /** @internal */\n  private selectedServer?: Server;\n  /** @internal */\n  private cursorNamespace: MongoDBNamespace;\n  /** @internal */\n  private documents: CursorResponse | null = null;\n  /** @internal */\n  private cursorClient: MongoClient;\n  /** @internal */\n  private transform?: (doc: TSchema) => any;\n  /**\n   * @internal\n   * This is true whether or not the first command fails. It only indicates whether or not the first\n   * command has been run.\n   */\n  private initialized: boolean;\n  /** @internal */\n  private isClosed: boolean;\n  /** @internal */\n  private isKilled: boolean;\n  /** @internal */\n  protected readonly cursorOptions: InternalAbstractCursorOptions;\n  /** @internal */\n  protected timeoutContext?: CursorTimeoutContext;\n\n  /** @event */\n  static readonly CLOSE = 'close' as const;\n\n  /** @internal */\n  protected deserializationOptions: OnDemandDocumentDeserializeOptions;\n\n  /** @internal */\n  protected constructor(\n    client: MongoClient,\n    namespace: MongoDBNamespace,\n    options: AbstractCursorOptions = {}\n  ) {\n    super();\n\n    if (!client.s.isMongoClient) {\n      throw new MongoRuntimeError('Cursor must be constructed with MongoClient');\n    }\n    this.cursorClient = client;\n    this.cursorNamespace = namespace;\n    this.cursorId = null;\n    this.initialized = false;\n    this.isClosed = false;\n    this.isKilled = false;\n    this.cursorOptions = {\n      readPreference:\n        options.readPreference && options.readPreference instanceof ReadPreference\n          ? options.readPreference\n          : ReadPreference.primary,\n      ...pluckBSONSerializeOptions(options),\n      timeoutMS: options?.timeoutContext?.csotEnabled()\n        ? options.timeoutContext.timeoutMS\n        : options.timeoutMS,\n      tailable: options.tailable,\n      awaitData: options.awaitData\n    };\n\n    if (this.cursorOptions.timeoutMS != null) {\n      if (options.timeoutMode == null) {\n        if (options.tailable) {\n          if (options.awaitData) {\n            if (\n              options.maxAwaitTimeMS != null &&\n              options.maxAwaitTimeMS >= this.cursorOptions.timeoutMS\n            )\n              throw new MongoInvalidArgumentError(\n                'Cannot specify maxAwaitTimeMS >= timeoutMS for a tailable awaitData cursor'\n              );\n          }\n\n          this.cursorOptions.timeoutMode = CursorTimeoutMode.ITERATION;\n        } else {\n          this.cursorOptions.timeoutMode = CursorTimeoutMode.LIFETIME;\n        }\n      } else {\n        if (options.tailable && options.timeoutMode === CursorTimeoutMode.LIFETIME) {\n          throw new MongoInvalidArgumentError(\n            \"Cannot set tailable cursor's timeoutMode to LIFETIME\"\n          );\n        }\n        this.cursorOptions.timeoutMode = options.timeoutMode;\n      }\n    } else {\n      if (options.timeoutMode != null)\n        throw new MongoInvalidArgumentError('Cannot set timeoutMode without setting timeoutMS');\n    }\n\n    // Set for initial command\n    this.cursorOptions.omitMaxTimeMS =\n      this.cursorOptions.timeoutMS != null &&\n      ((this.cursorOptions.timeoutMode === CursorTimeoutMode.ITERATION &&\n        !this.cursorOptions.tailable) ||\n        (this.cursorOptions.tailable && !this.cursorOptions.awaitData));\n\n    const readConcern = ReadConcern.fromOptions(options);\n    if (readConcern) {\n      this.cursorOptions.readConcern = readConcern;\n    }\n\n    if (typeof options.batchSize === 'number') {\n      this.cursorOptions.batchSize = options.batchSize;\n    }\n\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (options.comment !== undefined) {\n      this.cursorOptions.comment = options.comment;\n    }\n\n    if (typeof options.maxTimeMS === 'number') {\n      this.cursorOptions.maxTimeMS = options.maxTimeMS;\n    }\n\n    if (typeof options.maxAwaitTimeMS === 'number') {\n      this.cursorOptions.maxAwaitTimeMS = options.maxAwaitTimeMS;\n    }\n\n    if (options.session instanceof ClientSession) {\n      this.cursorSession = options.session;\n    } else {\n      this.cursorSession = this.cursorClient.startSession({ owner: this, explicit: false });\n    }\n\n    this.deserializationOptions = {\n      ...this.cursorOptions,\n      validation: {\n        utf8: options?.enableUtf8Validation === false ? false : true\n      }\n    };\n\n    this.timeoutContext = options.timeoutContext;\n  }\n\n  /**\n   * The cursor has no id until it receives a response from the initial cursor creating command.\n   *\n   * It is non-zero for as long as the database has an open cursor.\n   *\n   * The initiating command may receive a zero id if the entire result is in the `firstBatch`.\n   */\n  get id(): Long | undefined {\n    return this.cursorId ?? undefined;\n  }\n\n  /** @internal */\n  get isDead() {\n    return (this.cursorId?.isZero() ?? false) || this.isClosed || this.isKilled;\n  }\n\n  /** @internal */\n  get client(): MongoClient {\n    return this.cursorClient;\n  }\n\n  /** @internal */\n  get server(): Server | undefined {\n    return this.selectedServer;\n  }\n\n  get namespace(): MongoDBNamespace {\n    return this.cursorNamespace;\n  }\n\n  get readPreference(): ReadPreference {\n    return this.cursorOptions.readPreference;\n  }\n\n  get readConcern(): ReadConcern | undefined {\n    return this.cursorOptions.readConcern;\n  }\n\n  /** @internal */\n  get session(): ClientSession {\n    return this.cursorSession;\n  }\n\n  set session(clientSession: ClientSession) {\n    this.cursorSession = clientSession;\n  }\n\n  /**\n   * The cursor is closed and all remaining locally buffered documents have been iterated.\n   */\n  get closed(): boolean {\n    return this.isClosed && (this.documents?.length ?? 0) === 0;\n  }\n\n  /**\n   * A `killCursors` command was attempted on this cursor.\n   * This is performed if the cursor id is non zero.\n   */\n  get killed(): boolean {\n    return this.isKilled;\n  }\n\n  get loadBalanced(): boolean {\n    return !!this.cursorClient.topology?.loadBalanced;\n  }\n\n  /**\n   * @beta\n   * @experimental\n   * An alias for {@link AbstractCursor.close|AbstractCursor.close()}.\n   */\n  declare [Symbol.asyncDispose]: () => Promise<void>;\n  /** @internal */\n  async asyncDispose() {\n    await this.close();\n  }\n\n  /** Returns current buffered documents length */\n  bufferedCount(): number {\n    return this.documents?.length ?? 0;\n  }\n\n  /** Returns current buffered documents */\n  readBufferedDocuments(number?: number): NonNullable<TSchema>[] {\n    const bufferedDocs: NonNullable<TSchema>[] = [];\n    const documentsToRead = Math.min(\n      number ?? this.documents?.length ?? 0,\n      this.documents?.length ?? 0\n    );\n\n    for (let count = 0; count < documentsToRead; count++) {\n      const document = this.documents?.shift(this.deserializationOptions);\n      if (document != null) {\n        bufferedDocs.push(document);\n      }\n    }\n\n    return bufferedDocs;\n  }\n\n  async *[Symbol.asyncIterator](): AsyncGenerator<TSchema, void, void> {\n    if (this.closed) {\n      return;\n    }\n\n    try {\n      while (true) {\n        if (this.isKilled) {\n          return;\n        }\n\n        if (this.closed) {\n          return;\n        }\n\n        if (this.cursorId != null && this.isDead && (this.documents?.length ?? 0) === 0) {\n          return;\n        }\n\n        const document = await this.next();\n\n        // eslint-disable-next-line no-restricted-syntax\n        if (document === null) {\n          return;\n        }\n\n        yield document;\n      }\n    } finally {\n      // Only close the cursor if it has not already been closed. This finally clause handles\n      // the case when a user would break out of a for await of loop early.\n      if (!this.isClosed) {\n        try {\n          await this.close();\n        } catch (error) {\n          squashError(error);\n        }\n      }\n    }\n  }\n\n  stream(options?: CursorStreamOptions): Readable & AsyncIterable<TSchema> {\n    if (options?.transform) {\n      const transform = options.transform;\n      const readable = new ReadableCursorStream(this);\n\n      const transformedStream = readable.pipe(\n        new Transform({\n          objectMode: true,\n          highWaterMark: 1,\n          transform(chunk, _, callback) {\n            try {\n              const transformed = transform(chunk);\n              callback(undefined, transformed);\n            } catch (err) {\n              callback(err);\n            }\n          }\n        })\n      );\n\n      // Bubble errors to transformed stream, because otherwise no way\n      // to handle this error.\n      readable.on('error', err => transformedStream.emit('error', err));\n\n      return transformedStream;\n    }\n\n    return new ReadableCursorStream(this);\n  }\n\n  async hasNext(): Promise<boolean> {\n    if (this.cursorId === Long.ZERO) {\n      return false;\n    }\n\n    if (this.cursorOptions.timeoutMode === CursorTimeoutMode.ITERATION && this.cursorId != null) {\n      this.timeoutContext?.refresh();\n    }\n    try {\n      do {\n        if ((this.documents?.length ?? 0) !== 0) {\n          return true;\n        }\n        await this.fetchBatch();\n      } while (!this.isDead || (this.documents?.length ?? 0) !== 0);\n    } finally {\n      if (this.cursorOptions.timeoutMode === CursorTimeoutMode.ITERATION) {\n        this.timeoutContext?.clear();\n      }\n    }\n\n    return false;\n  }\n\n  /** Get the next available document from the cursor, returns null if no more documents are available. */\n  async next(): Promise<TSchema | null> {\n    if (this.cursorId === Long.ZERO) {\n      throw new MongoCursorExhaustedError();\n    }\n\n    if (this.cursorOptions.timeoutMode === CursorTimeoutMode.ITERATION && this.cursorId != null) {\n      this.timeoutContext?.refresh();\n    }\n\n    try {\n      do {\n        const doc = this.documents?.shift(this.deserializationOptions);\n        if (doc != null) {\n          if (this.transform != null) return await this.transformDocument(doc);\n          return doc;\n        }\n        await this.fetchBatch();\n      } while (!this.isDead || (this.documents?.length ?? 0) !== 0);\n    } finally {\n      if (this.cursorOptions.timeoutMode === CursorTimeoutMode.ITERATION) {\n        this.timeoutContext?.clear();\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Try to get the next available document from the cursor or `null` if an empty batch is returned\n   */\n  async tryNext(): Promise<TSchema | null> {\n    if (this.cursorId === Long.ZERO) {\n      throw new MongoCursorExhaustedError();\n    }\n\n    if (this.cursorOptions.timeoutMode === CursorTimeoutMode.ITERATION && this.cursorId != null) {\n      this.timeoutContext?.refresh();\n    }\n    try {\n      let doc = this.documents?.shift(this.deserializationOptions);\n      if (doc != null) {\n        if (this.transform != null) return await this.transformDocument(doc);\n        return doc;\n      }\n\n      await this.fetchBatch();\n\n      doc = this.documents?.shift(this.deserializationOptions);\n      if (doc != null) {\n        if (this.transform != null) return await this.transformDocument(doc);\n        return doc;\n      }\n    } finally {\n      if (this.cursorOptions.timeoutMode === CursorTimeoutMode.ITERATION) {\n        this.timeoutContext?.clear();\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Iterates over all the documents for this cursor using the iterator, callback pattern.\n   *\n   * If the iterator returns `false`, iteration will stop.\n   *\n   * @param iterator - The iteration callback.\n   * @deprecated - Will be removed in a future release. Use for await...of instead.\n   */\n  async forEach(iterator: (doc: TSchema) => boolean | void): Promise<void> {\n    if (typeof iterator !== 'function') {\n      throw new MongoInvalidArgumentError('Argument \"iterator\" must be a function');\n    }\n    for await (const document of this) {\n      const result = iterator(document);\n      if (result === false) {\n        break;\n      }\n    }\n  }\n\n  /**\n   * Frees any client-side resources used by the cursor.\n   */\n  async close(options?: { timeoutMS?: number }): Promise<void> {\n    await this.cleanup(options?.timeoutMS);\n  }\n\n  /**\n   * Returns an array of documents. The caller is responsible for making sure that there\n   * is enough memory to store the results. Note that the array only contains partial\n   * results when this cursor had been previously accessed. In that case,\n   * cursor.rewind() can be used to reset the cursor.\n   */\n  async toArray(): Promise<TSchema[]> {\n    const array: TSchema[] = [];\n    // at the end of the loop (since readBufferedDocuments is called) the buffer will be empty\n    // then, the 'await of' syntax will run a getMore call\n    for await (const document of this) {\n      array.push(document);\n      const docs = this.readBufferedDocuments();\n      if (this.transform != null) {\n        for (const doc of docs) {\n          array.push(await this.transformDocument(doc));\n        }\n      } else {\n        array.push(...docs);\n      }\n    }\n    return array;\n  }\n  /**\n   * Add a cursor flag to the cursor\n   *\n   * @param flag - The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial' -.\n   * @param value - The flag boolean value.\n   */\n  addCursorFlag(flag: CursorFlag, value: boolean): this {\n    this.throwIfInitialized();\n    if (!CURSOR_FLAGS.includes(flag)) {\n      throw new MongoInvalidArgumentError(`Flag ${flag} is not one of ${CURSOR_FLAGS}`);\n    }\n\n    if (typeof value !== 'boolean') {\n      throw new MongoInvalidArgumentError(`Flag ${flag} must be a boolean value`);\n    }\n\n    this.cursorOptions[flag] = value;\n    return this;\n  }\n\n  /**\n   * Map all documents using the provided function\n   * If there is a transform set on the cursor, that will be called first and the result passed to\n   * this function's transform.\n   *\n   * @remarks\n   *\n   * **Note** Cursors use `null` internally to indicate that there are no more documents in the cursor. Providing a mapping\n   * function that maps values to `null` will result in the cursor closing itself before it has finished iterating\n   * all documents.  This will **not** result in a memory leak, just surprising behavior.  For example:\n   *\n   * ```typescript\n   * const cursor = collection.find({});\n   * cursor.map(() => null);\n   *\n   * const documents = await cursor.toArray();\n   * // documents is always [], regardless of how many documents are in the collection.\n   * ```\n   *\n   * Other falsey values are allowed:\n   *\n   * ```typescript\n   * const cursor = collection.find({});\n   * cursor.map(() => '');\n   *\n   * const documents = await cursor.toArray();\n   * // documents is now an array of empty strings\n   * ```\n   *\n   * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\n   * it **does not** return a new instance of a cursor. This means when calling map,\n   * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\n   * Take note of the following example:\n   *\n   * @example\n   * ```typescript\n   * const cursor: FindCursor<Document> = coll.find();\n   * const mappedCursor: FindCursor<number> = cursor.map(doc => Object.keys(doc).length);\n   * const keyCounts: number[] = await mappedCursor.toArray(); // cursor.toArray() still returns Document[]\n   * ```\n   * @param transform - The mapping transformation method.\n   */\n  map<T = any>(transform: (doc: TSchema) => T): AbstractCursor<T> {\n    this.throwIfInitialized();\n    const oldTransform = this.transform;\n    if (oldTransform) {\n      this.transform = doc => {\n        return transform(oldTransform(doc));\n      };\n    } else {\n      this.transform = transform;\n    }\n\n    return this as unknown as AbstractCursor<T>;\n  }\n\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n  withReadPreference(readPreference: ReadPreferenceLike): this {\n    this.throwIfInitialized();\n    if (readPreference instanceof ReadPreference) {\n      this.cursorOptions.readPreference = readPreference;\n    } else if (typeof readPreference === 'string') {\n      this.cursorOptions.readPreference = ReadPreference.fromString(readPreference);\n    } else {\n      throw new MongoInvalidArgumentError(`Invalid read preference: ${readPreference}`);\n    }\n\n    return this;\n  }\n\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n  withReadConcern(readConcern: ReadConcernLike): this {\n    this.throwIfInitialized();\n    const resolvedReadConcern = ReadConcern.fromOptions({ readConcern });\n    if (resolvedReadConcern) {\n      this.cursorOptions.readConcern = resolvedReadConcern;\n    }\n\n    return this;\n  }\n\n  /**\n   * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)\n   *\n   * @param value - Number of milliseconds to wait before aborting the query.\n   */\n  maxTimeMS(value: number): this {\n    this.throwIfInitialized();\n    if (typeof value !== 'number') {\n      throw new MongoInvalidArgumentError('Argument for maxTimeMS must be a number');\n    }\n\n    this.cursorOptions.maxTimeMS = value;\n    return this;\n  }\n\n  /**\n   * Set the batch size for the cursor.\n   *\n   * @param value - The number of documents to return per batch. See {@link https://www.mongodb.com/docs/manual/reference/command/find/|find command documentation}.\n   */\n  batchSize(value: number): this {\n    this.throwIfInitialized();\n    if (this.cursorOptions.tailable) {\n      throw new MongoTailableCursorError('Tailable cursor does not support batchSize');\n    }\n\n    if (typeof value !== 'number') {\n      throw new MongoInvalidArgumentError('Operation \"batchSize\" requires an integer');\n    }\n\n    this.cursorOptions.batchSize = value;\n    return this;\n  }\n\n  /**\n   * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will\n   * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even\n   * if the resultant data has already been retrieved by this cursor.\n   */\n  rewind(): void {\n    if (this.timeoutContext && this.timeoutContext.owner !== this) {\n      throw new MongoAPIError(`Cannot rewind cursor that does not own its timeout context.`);\n    }\n    if (!this.initialized) {\n      return;\n    }\n\n    this.cursorId = null;\n    this.documents?.clear();\n    this.timeoutContext?.clear();\n    this.timeoutContext = undefined;\n    this.isClosed = false;\n    this.isKilled = false;\n    this.initialized = false;\n\n    const session = this.cursorSession;\n    if (session) {\n      // We only want to end this session if we created it, and it hasn't ended yet\n      if (session.explicit === false) {\n        if (!session.hasEnded) {\n          session.endSession().then(undefined, squashError);\n        }\n        this.cursorSession = this.cursorClient.startSession({ owner: this, explicit: false });\n      }\n    }\n  }\n\n  /**\n   * Returns a new uninitialized copy of this cursor, with options matching those that have been set on the current instance\n   */\n  abstract clone(): AbstractCursor<TSchema>;\n\n  /** @internal */\n  protected abstract _initialize(\n    session: ClientSession | undefined\n  ): Promise<InitialCursorResponse>;\n\n  /** @internal */\n  async getMore(batchSize: number): Promise<CursorResponse> {\n    if (this.cursorId == null) {\n      throw new MongoRuntimeError(\n        'Unexpected null cursor id. A cursor creating command should have set this'\n      );\n    }\n    if (this.selectedServer == null) {\n      throw new MongoRuntimeError(\n        'Unexpected null selectedServer. A cursor creating command should have set this'\n      );\n    }\n    const getMoreOptions = {\n      ...this.cursorOptions,\n      session: this.cursorSession,\n      batchSize\n    };\n\n    const getMoreOperation = new GetMoreOperation(\n      this.cursorNamespace,\n      this.cursorId,\n      this.selectedServer,\n      getMoreOptions\n    );\n\n    return await executeOperation(this.cursorClient, getMoreOperation, this.timeoutContext);\n  }\n\n  /**\n   * @internal\n   *\n   * This function is exposed for the unified test runner's createChangeStream\n   * operation.  We cannot refactor to use the abstract _initialize method without\n   * a significant refactor.\n   */\n  private async cursorInit(): Promise<void> {\n    if (this.cursorOptions.timeoutMS != null) {\n      this.timeoutContext ??= new CursorTimeoutContext(\n        TimeoutContext.create({\n          serverSelectionTimeoutMS: this.client.s.options.serverSelectionTimeoutMS,\n          timeoutMS: this.cursorOptions.timeoutMS\n        }),\n        this\n      );\n    }\n    try {\n      const state = await this._initialize(this.cursorSession);\n      // Set omitMaxTimeMS to the value needed for subsequent getMore calls\n      this.cursorOptions.omitMaxTimeMS = this.cursorOptions.timeoutMS != null;\n      const response = state.response;\n      this.selectedServer = state.server;\n      this.cursorId = response.id;\n      this.cursorNamespace = response.ns ?? this.namespace;\n      this.documents = response;\n      this.initialized = true; // the cursor is now initialized, even if it is dead\n    } catch (error) {\n      // the cursor is now initialized, even if an error occurred\n      this.initialized = true;\n      await this.cleanup(undefined, error);\n      throw error;\n    }\n\n    if (this.isDead) {\n      await this.cleanup();\n    }\n\n    return;\n  }\n\n  /** @internal Attempt to obtain more documents */\n  private async fetchBatch(): Promise<void> {\n    if (this.isClosed) {\n      return;\n    }\n\n    if (this.isDead) {\n      // if the cursor is dead, we clean it up\n      // cleanupCursor should never throw, but if it does it indicates a bug in the driver\n      // and we should surface the error\n      await this.cleanup();\n      return;\n    }\n\n    if (this.cursorId == null) {\n      await this.cursorInit();\n      // If the cursor died or returned documents, return\n      if ((this.documents?.length ?? 0) !== 0 || this.isDead) return;\n      // Otherwise, run a getMore\n    }\n\n    // otherwise need to call getMore\n    const batchSize = this.cursorOptions.batchSize || 1000;\n\n    try {\n      const response = await this.getMore(batchSize);\n      this.cursorId = response.id;\n      this.documents = response;\n    } catch (error) {\n      try {\n        await this.cleanup(undefined, error);\n      } catch (cleanupError) {\n        // `cleanupCursor` should never throw, squash and throw the original error\n        squashError(cleanupError);\n      }\n      throw error;\n    }\n\n    if (this.isDead) {\n      // If we successfully received a response from a cursor BUT the cursor indicates that it is exhausted,\n      // we intentionally clean up the cursor to release its session back into the pool before the cursor\n      // is iterated.  This prevents a cursor that is exhausted on the server from holding\n      // onto a session indefinitely until the AbstractCursor is iterated.\n      //\n      // cleanupCursorAsync should never throw, but if it does it indicates a bug in the driver\n      // and we should surface the error\n      await this.cleanup();\n    }\n  }\n\n  /** @internal */\n  private async cleanup(timeoutMS?: number, error?: Error) {\n    this.isClosed = true;\n    const session = this.cursorSession;\n    const timeoutContextForKillCursors = (): CursorTimeoutContext | undefined => {\n      if (timeoutMS != null) {\n        this.timeoutContext?.clear();\n        return new CursorTimeoutContext(\n          TimeoutContext.create({\n            serverSelectionTimeoutMS: this.client.s.options.serverSelectionTimeoutMS,\n            timeoutMS\n          }),\n          this\n        );\n      } else {\n        return this.timeoutContext?.refreshed();\n      }\n    };\n    try {\n      if (\n        !this.isKilled &&\n        this.cursorId &&\n        !this.cursorId.isZero() &&\n        this.cursorNamespace &&\n        this.selectedServer &&\n        !session.hasEnded\n      ) {\n        this.isKilled = true;\n        const cursorId = this.cursorId;\n        this.cursorId = Long.ZERO;\n\n        await executeOperation(\n          this.cursorClient,\n          new KillCursorsOperation(cursorId, this.cursorNamespace, this.selectedServer, {\n            session\n          }),\n          timeoutContextForKillCursors()\n        );\n      }\n    } catch (error) {\n      squashError(error);\n    } finally {\n      if (session?.owner === this) {\n        await session.endSession({ error });\n      }\n      if (!session?.inTransaction()) {\n        maybeClearPinnedConnection(session, { error });\n      }\n\n      this.emitClose();\n    }\n  }\n\n  /** @internal */\n  private hasEmittedClose = false;\n  /** @internal */\n  private emitClose() {\n    try {\n      if (!this.hasEmittedClose && ((this.documents?.length ?? 0) === 0 || this.isClosed)) {\n        // @ts-expect-error: CursorEvents is generic so Parameters<CursorEvents[\"close\"]> may not be assignable to `[]`. Not sure how to require extenders do not add parameters.\n        this.emit('close');\n      }\n    } finally {\n      this.hasEmittedClose = true;\n    }\n  }\n\n  /** @internal */\n  private async transformDocument(document: NonNullable<TSchema>): Promise<NonNullable<TSchema>> {\n    if (this.transform == null) return document;\n\n    try {\n      const transformedDocument = this.transform(document);\n      // eslint-disable-next-line no-restricted-syntax\n      if (transformedDocument === null) {\n        const TRANSFORM_TO_NULL_ERROR =\n          'Cursor returned a `null` document, but the cursor is not exhausted.  Mapping documents to `null` is not supported in the cursor transform.';\n        throw new MongoAPIError(TRANSFORM_TO_NULL_ERROR);\n      }\n      return transformedDocument;\n    } catch (transformError) {\n      try {\n        await this.close();\n      } catch (closeError) {\n        squashError(closeError);\n      }\n      throw transformError;\n    }\n  }\n\n  /** @internal */\n  protected throwIfInitialized() {\n    if (this.initialized) throw new MongoCursorInUseError();\n  }\n}\n\nclass ReadableCursorStream extends Readable {\n  private _cursor: AbstractCursor;\n  private _readInProgress = false;\n\n  constructor(cursor: AbstractCursor) {\n    super({\n      objectMode: true,\n      autoDestroy: false,\n      highWaterMark: 1\n    });\n    this._cursor = cursor;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  override _read(size: number): void {\n    if (!this._readInProgress) {\n      this._readInProgress = true;\n      this._readNext();\n    }\n  }\n\n  override _destroy(error: Error | null, callback: (error?: Error | null) => void): void {\n    this._cursor.close().then(\n      () => callback(error),\n      closeError => callback(closeError)\n    );\n  }\n\n  private _readNext() {\n    if (this._cursor.id === Long.ZERO) {\n      this.push(null);\n      return;\n    }\n\n    this._cursor.next().then(\n      result => {\n        if (result == null) {\n          this.push(null);\n        } else if (this.destroyed) {\n          this._cursor.close().then(undefined, squashError);\n        } else {\n          if (this.push(result)) {\n            return this._readNext();\n          }\n\n          this._readInProgress = false;\n        }\n      },\n      err => {\n        // NOTE: This is questionable, but we have a test backing the behavior. It seems the\n        //       desired behavior is that a stream ends cleanly when a user explicitly closes\n        //       a client during iteration. Alternatively, we could do the \"right\" thing and\n        //       propagate the error message by removing this special case.\n        if (err.message.match(/server is closed/)) {\n          this._cursor.close().then(undefined, squashError);\n          return this.push(null);\n        }\n\n        // NOTE: This is also perhaps questionable. The rationale here is that these errors tend\n        //       to be \"operation was interrupted\", where a cursor has been closed but there is an\n        //       active getMore in-flight. This used to check if the cursor was killed but once\n        //       that changed to happen in cleanup legitimate errors would not destroy the\n        //       stream. There are change streams test specifically test these cases.\n        if (err.message.match(/operation was interrupted/)) {\n          return this.push(null);\n        }\n\n        // NOTE: The two above checks on the message of the error will cause a null to be pushed\n        //       to the stream, thus closing the stream before the destroy call happens. This means\n        //       that either of those error messages on a change stream will not get a proper\n        //       'error' event to be emitted (the error passed to destroy). Change stream resumability\n        //       relies on that error event to be emitted to create its new cursor and thus was not\n        //       working on 4.4 servers because the error emitted on failover was \"interrupted at\n        //       shutdown\" while on 5.0+ it is \"The server is in quiesce mode and will shut down\".\n        //       See NODE-4475.\n        return this.destroy(err);\n      }\n    );\n  }\n}\n\nconfigureResourceManagement(AbstractCursor.prototype);\n\n/**\n * @internal\n * The cursor timeout context is a wrapper around a timeout context\n * that keeps track of the \"owner\" of the cursor.  For timeout contexts\n * instantiated inside a cursor, the owner will be the cursor.\n *\n * All timeout behavior is exactly the same as the wrapped timeout context's.\n */\nexport class CursorTimeoutContext extends TimeoutContext {\n  constructor(\n    public timeoutContext: TimeoutContext,\n    public owner: symbol | AbstractCursor\n  ) {\n    super();\n  }\n  override get serverSelectionTimeout(): Timeout | null {\n    return this.timeoutContext.serverSelectionTimeout;\n  }\n  override get connectionCheckoutTimeout(): Timeout | null {\n    return this.timeoutContext.connectionCheckoutTimeout;\n  }\n  override get clearServerSelectionTimeout(): boolean {\n    return this.timeoutContext.clearServerSelectionTimeout;\n  }\n  override get timeoutForSocketWrite(): Timeout | null {\n    return this.timeoutContext.timeoutForSocketWrite;\n  }\n  override get timeoutForSocketRead(): Timeout | null {\n    return this.timeoutContext.timeoutForSocketRead;\n  }\n  override csotEnabled(): this is CSOTTimeoutContext {\n    return this.timeoutContext.csotEnabled();\n  }\n  override refresh(): void {\n    if (typeof this.owner !== 'symbol') return this.timeoutContext.refresh();\n  }\n  override clear(): void {\n    if (typeof this.owner !== 'symbol') return this.timeoutContext.clear();\n  }\n  override get maxTimeMS(): number | null {\n    return this.timeoutContext.maxTimeMS;\n  }\n  get timeoutMS(): number | null {\n    return this.timeoutContext.csotEnabled() ? this.timeoutContext.timeoutMS : null;\n  }\n  override refreshed(): CursorTimeoutContext {\n    return new CursorTimeoutContext(this.timeoutContext.refreshed(), this.owner);\n  }\n  override addMaxTimeMSToCommand(command: Document, options: { omitMaxTimeMS?: boolean }): void {\n    this.timeoutContext.addMaxTimeMSToCommand(command, options);\n  }\n  override getSocketTimeoutMS(): number | undefined {\n    return this.timeoutContext.getSocketTimeoutMS();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}